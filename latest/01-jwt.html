<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>JWT (Json Web Token)</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">buddy/buddy-sign</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-intro.html"><div class="inner"><span>Introduction</span></div></a></li><li class="depth-1  current"><a href="01-jwt.html"><div class="inner"><span>JWT (Json Web Token)</span></div></a></li><li class="depth-1 "><a href="02-jws.html"><div class="inner"><span>JWS (Json Web Signature)</span></div></a></li><li class="depth-1 "><a href="03-jwe.html"><div class="inner"><span>JWE (Json Web Encryption)</span></div></a></li><li class="depth-1 "><a href="04-cms.html"><div class="inner"><span>CMS (Compact Message Signing)</span></div></a></li><li class="depth-1 "><a href="05-faq.html"><div class="inner"><span>FAQ</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buddy</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sign</span></div></div></li><li class="depth-3 branch"><a href="buddy.sign.compact.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compact</span></div></a></li><li class="depth-3"><a href="buddy.sign.jwe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jwe</span></div></a></li><li class="depth-4"><a href="buddy.sign.jwe.cek.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cek</span></div></a></li><li class="depth-3 branch"><a href="buddy.sign.jws.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>jws</span></div></a></li><li class="depth-3 branch"><a href="buddy.sign.jwt.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jwt</span></div></a></li><li class="depth-3"><a href="buddy.sign.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#jwt-json-web-token" id="jwt-json-web-token"></a>JWT (Json Web Token)</h1>
<p>JSON Web Token (JWT) is a compact claims representation format intended for space constrained environments such as HTTP Authorization headers and URI query parameters.  JWTs encode claims to be transmitted as a JavaScript Object Notation (JSON) object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or MACed and/or encrypted.</p>
<h2><a href="#supported-algorithms" id="supported-algorithms"></a>Supported algorithms</h2>
<p>Here a table of supported algorithms for signing JWT claims using JWS (Json Web Signature):</p>
<table>
<thead>
<tr><th>Algorithm name     </th><th> Hash algorithms   </th><th> Keywords           </th><th> Priv/Pub Key? </th></tr>
</thead>
<tbody>
<tr><td>Elliptic Curve DSA </td><td> sha256, sha512    </td><td> <code>:es256</code>, <code>:es512</code> </td><td> Yes </td></tr>
<tr><td>Edwards Curve DSA  </td><td> sha512            </td><td> <code>:eddsa</code>           </td><td> Yes </td></tr>
<tr><td>RSASSA PSS         </td><td> sha256, sha512    </td><td> <code>:ps256</code>, <code>:ps512</code> </td><td> Yes </td></tr>
<tr><td>RSASSA PKCS1 v1_5  </td><td> sha256, sha512    </td><td> <code>:rs256</code>, <code>:rs512</code> </td><td> Yes </td></tr>
<tr><td>HMAC               </td><td> sha256*, sha512   </td><td> <code>:hs256</code>, <code>:hs512</code> </td><td> No </td></tr>
</tbody>
</table>
<p>The JWE (Json Web Encryption) in difference to JWS uses two types of algoritms: key encryption algorithms and content encryption algorithms.</p>
<p>The <em>key encryption algorithms</em> are responsible of encrypt the key that will be used for encrypt the content. This is a table that exposes the currently supported <em>Key Encryption Algorithms</em> (specified in JWA RFC):</p>
<table>
<thead>
<tr><th> Algorithm name </th><th> Decription </th><th> Keyword       </th><th> Shared Key Size </th></tr>
</thead>
<tbody>
<tr><td> DIR            </td><td> Direct use of a shared symmetric key </td><td> <code>:dir</code> </td><td> (depends on content encryption algorithm) </td></tr>
<tr><td> A128KW         </td><td> AES128 Key Wrap </td><td> <code>:a128kw</code> </td><td> 16 bytes </td></tr>
<tr><td> A192KW         </td><td> AES192 Key Wrap </td><td> <code>:a192kw</code> </td><td> 24 bytes </td></tr>
<tr><td> A256KW         </td><td> AES256 Key Wrap </td><td> <code>:a256kw</code> </td><td> 32 bytes </td></tr>
<tr><td> RSA1_5         </td><td> RSA PKCS1 V1_5  </td><td> <code>:rsa1_5</code> </td><td> Asymetric key pair </td></tr>
<tr><td> RSA-OAEP       </td><td> RSA OAEP with SHA1 </td><td> <code>:rsa-oaep</code> </td><td> Asymetric key pair </td></tr>
<tr><td> RSA-OAEP-256   </td><td> RSA OAEP with SHA256 </td><td> <code>:rsa-oaep-256</code> </td><td> Asymetric key pair </td></tr>
</tbody>
</table>
<p>The <em>content encryption algoritms</em> are responsible of encrypt the content. This is a table that exposes the currently supported <em>Content Encryption Algorithms</em> (all specified in the JWA RFC):</p>
<table>
<thead>
<tr><th> Algorithm name </th><th> Description </th><th> Keyword </th><th> Shared Key Size </th></tr>
</thead>
<tbody>
<tr><td> A128CBC-HS256  </td><td> AES128 with CBC mode and HMAC-SHA256  </td><td> <code>:a128cbc-hs256</code> </td><td> 32 bytes </td></tr>
<tr><td> A192CBC-HS384  </td><td> AES192 with CBC mode and HMAC-SHA384  </td><td> <code>:a192cbc-hs384</code> </td><td> 48 bytes </td></tr>
<tr><td> A256CBC-HS512  </td><td> AES256 with CBC mode and HMAC-SHA512  </td><td> <code>:a256cbc-hs512</code> </td><td> 64 bytes </td></tr>
<tr><td> A128GCM        </td><td> AES128 with GCM mode </td><td> <code>:a128gcm</code>    </td><td> 16 bytes </td></tr>
<tr><td> A192GCM        </td><td> AES192 with GCM mode </td><td> <code>:a192gcm</code>    </td><td> 24 bytes </td></tr>
<tr><td> A256GCM        </td><td> AES256 with GCM mode </td><td> <code>:a256gcm</code>    </td><td> 32 bytes </td></tr>
</tbody>
</table>
<h2><a href="#signing-data" id="signing-data"></a>Signing data</h2>
<p>Let start with signing data. For it we will use the <code>sign</code> function from <code>buddy.sign.jws</code> namespace, and the <code>hs256</code> algorithm for signining:</p>
<pre><code class="language-clojure">(require '[buddy.sign.jwt :as jwt])

(jwt/sign {:userid 1} "secret")
;; "eyJ0eXAiOiJKV1MiLCJhbGciOiJIU..."
</code></pre>
<p>The <code>sign</code> function return a encoded and signed token as plain <code>String</code> instance or an exception in case of something goes wrong. As you can observe, no algorithm is passed as parameter. In this situations the default one will be used, and in this case is <code>:hs256</code>.</p>
<p><strong>NOTE</strong>: Due to the nature of the storage format, the input is restricted mainly to json objects in the current version.</p>
<h2><a href="#unsigning-data" id="unsigning-data"></a>Unsigning data</h2>
<p>Itâ€™s time to unsign data. That process consists on verify the signature of incoming data and return the plain data (without signature). For it we will use the <code>unsign</code> function from <code>buddy.sign.jwt</code> namespace:</p>
<pre><code class="language-clojure">(jwt/unsign data "secret")
;; =&gt; {:userid 1}
</code></pre>
<h2><a href="#claims-validation" id="claims-validation"></a>Claims validation</h2>
<p><em>buddy-sign</em> JWT implements validation of a concrete subset of claims: <em>iat</em> (issue time), <em>exp</em> (expiration time), <em>nbf</em> (not before), <em>iss</em> (issuer) and <em>aud</em> (audience).</p>
<p>The validation is performed on decoding the token. If <code>:exp</code> claim is found and is posterior to the current date time (UTC) an validation exception will be raised.  Alternatively, the time to validate token against can be specified as <code>:now</code> option to <code>unsign</code>.</p>
<p>Additionaly, if you want to provide some leeway for the claims validation, you can pass the <code>:leeway</code> option to the <code>unsign</code> function.</p>
<p>Let see an example using direct api:</p>
<pre><code class="language-clojure">(require '[clj-time.core :as time])

;; Define claims with `:exp` key
(def claims
  {:user 1 :exp (time/plus (time/now) (time/seconds 5))})

;; Serialize and sign a token with previously defined claims
(def token (jwt/sign claims "key"))

;; wait 5 seconds and try unsign it

(jwt/unsign token "key")
;; =&gt; ExceptionInfo "Token is older than :exp (1427836475)"

;; use timestamp in the past
(jwt/unsign token "key" {:now (time/minus (time/now) (time/seconds 5))})
;; =&gt; {:user 1}
</code></pre>
<h2><a href="#encrypting-data" id="encrypting-data"></a>Encrypting data</h2>
<p>Let start with encrypting data. For it we will use the <code>encrypt</code> function from the <code>buddy.sign.jwt</code> namespace:</p>
<pre><code class="language-clojure">(require '[buddy.sign.jwt :as jwt])
(require '[buddy.core.hash :as hash])

;; Hash your secret key with sha256 for
;; create a byte array of 32 bytes because
;; is a requirement for default content
;; encryption algorithm

(def secret (hash/sha256 "mysecret"))

;; Encrypt it using the previously
;; hashed key

(jwt/encrypt {:userid 1} secret {:alg :dir :enc :a128cbc-hs256})
;; "eyJ0eXAiOiJKV1MiLCJhbGciOiJIU..."
</code></pre>
<p>The <code>encrypt</code> function, like <code>sign</code> from <em>JWT</em>, returns a plain string with encrypted and encoded content using a provided algorithm and shared secret key.</p>
<h2><a href="#decrypting-data" id="decrypting-data"></a>Decrypting Data</h2>
<p>The decrypt is a inverse process, that takes encrypted data and the shared key, and returns the plain data. For it, <em>buddy-sign</em> exposes the <code>decrypt</code> function.  Let see how you can use it:</p>
<pre><code class="language-clojure">(jwt/decrypt incoming-data secret)
;; =&gt; {:userid 1}
</code></pre>
<h2><a href="#digital-signature-algorithms" id="digital-signature-algorithms"></a>Digital signature algorithms</h2>
<p>In order to use any of digital signature algorithms you must have a private/public key. If you donâ€™t have one, donâ€™t worry, it is very easy to generate it using <em>openssl</em> (<a href="./05-faq.html">look on FAQ</a>).</p>
<p>Having generated a key pair, you can sign your messages using one of supported digital signature algorithms.</p>
<p>Example of signing a string using <em>es256</em> (eliptic curve dsa) algorithm:</p>
<pre><code class="language-clojure">(require '[buddy.core.keys :as keys])

;; Create keys instances
(def ec-privkey (keys/private-key "ecprivkey.pem"))
(def ec-pubkey (keys/public-key "ecpubkey.pem"))

;; Use them like plain secret password with hmac algorithms for sign
(def signed-data (jwt/sign {:foo "bar"} ec-privkey {:alg :es256}))

;; And unsign
(def unsigned-data (jwt/unsign signed-data ec-pubkey {:alg :es256}))
</code></pre>
<h2><a href="#asymetric-encryption" id="asymetric-encryption"></a>Asymetric encryption</h2>
<p>In order to use any asymetric encryption algorithm, you should have private/public key pair. If you donâ€™t have one, donâ€™t worry, it is very easy to generate it using <em>openssl</em> (<a href="./05-faq.html">look on FAQ</a>).</p>
<p>Then, having ready the key pair, you can strart using one of the supported key encryption algorithm in the JWE specification such as <code>:rsa1_5</code>, <code>:rsa-oaep</code> or <code>:rsa-oaep-256</code>.</p>
<p>Let see an demonstration example:</p>
<pre><code class="language-clojure">(require '[buddy.core.keys :as keys])

;; Create keys instances
(def privkey (keys/private-key "privkey.pem"))
(def pubkey (keys/public-key "pubkey.pem"))

;; Encrypt data
(def encrypted-data (jwt/encrypt {:foo "bar"} pubkey
                                 {:alg :rsa-oaep
                                  :enc :a128cbc-hs256})

;; Decrypted
(def decrypted-data (jwt/decrypt encrypted-data privkey
                                 {:alg :rsa-oaep
                                  :enc :a128cbc-hs256}))
</code></pre>
</div></div></div></body></html>